#include <memory>
#include <thread>

#include "rclcpp/rclcpp.hpp"
// #include <rcpputils/asserts.hpp>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>

#include <robast_map_update_module/map_combine_node.hpp>

namespace robast_map_update
{
MapCombine::MapCombine(): Node("map_combine_node")
{
        
        using std::placeholders::_1;
        _merging_rate = 0.5;

        auto qos = rclcpp::QoS(rclcpp::KeepLast(1)).transient_local().best_effort();

        //map generated by the slam_toolbox. Annahme: map ändert sich oft
        _slam_map_getter = this->create_subscription<nav_msgs::msg::OccupancyGrid>(
                "/slam_map", qos, std::bind(&MapCombine::slam_map_subscriber, this, _1));

        // provided by the map_server. Annahme: die map ändert sich eigentlich nicht wirklich.
        _base_map_getter = this->create_subscription<nav_msgs::msg::OccupancyGrid>(
                "/base_map", qos, std::bind(&MapCombine::base_map_subscriber, this, _1));

        // map publisher
        _merged_map_publisher = this->create_publisher<nav_msgs::msg::OccupancyGrid>(
                "/map", rclcpp::QoS(rclcpp::KeepLast(1)).transient_local().reliable());

        // map publisher
        _debug_base_map_publisher = this->create_publisher<nav_msgs::msg::OccupancyGrid>(
                "/debug_map", rclcpp::QoS(rclcpp::KeepLast(1)).transient_local().reliable());

        // Timers
        _map_merging_timer = this->create_wall_timer(
                std::chrono::milliseconds((uint16_t)(1000.0 / _merging_rate)),
                [this]() { mapCombination(); });
        _map_merging_timer->execute_callback();

        // For topicSubscribing() we need to spin briefly for the discovery to happen
        rclcpp::Rate r(100);
        int i = 0;
        while (rclcpp::ok() && i < 100) {
                rclcpp::spin_some(this->get_node_base_interface());
                r.sleep();
                i++;
        }

}

void MapCombine::slam_map_subscriber(const nav_msgs::msg::OccupancyGrid::SharedPtr msg)
{
        // updateSlamMap(msg);
        _slam_map = msg;
        // mapCombination();
        RCLCPP_DEBUG(this->get_logger(), "Received new slam map");
}

void MapCombine::base_map_subscriber(const nav_msgs::msg::OccupancyGrid::SharedPtr msg)
{
        _base_map = msg;
        RCLCPP_DEBUG(this->get_logger(), "Received new base map");
}

void MapCombine::updateSlamMap(const nav_msgs::msg::OccupancyGrid::SharedPtr map)
{
        RCLCPP_DEBUG(this->get_logger(), "recieved map update");
        // std::lock_guard<std::mutex> lock(subscription.mutex);
  
        // ros2 header .stamp don't support > operator, we need to create them explicitly
        auto t1 = rclcpp::Time(_combined_map->header.stamp);
        auto t2 = rclcpp::Time(map->header.stamp);
        if (t1 > t2) {
                // we have been overrunned by faster update. our work was useless.
                RCLCPP_INFO(this->get_logger(), "Slam map failed due to too old time stamp");
                return;
        }
        std::lock_guard<std::mutex> lock(_pipeline_mutex);
        _slam_map = map;
        RCLCPP_DEBUG(this->get_logger(), "Slam map updated successfully");
}

void pose_to_transform(geometry_msgs::msg::Transform* transform, geometry_msgs::msg::Pose* pose)
{
        // transform->rotation = pose->orientation;
        transform->translation.x = pose->position.x;
        transform->translation.y = pose->position.y;
        transform->translation.z = pose->position.z;
}

void MapCombine::mapCombination(){
        std::vector<nav_msgs::msg::OccupancyGrid::ConstSharedPtr> grids;
        std::vector<geometry_msgs::msg::Transform> transforms;

        if(_base_map)
        {
                grids.push_back(_base_map);
                geometry_msgs::msg::Transform base_transform = geometry_msgs::msg::Transform();
                pose_to_transform(&base_transform, &(_base_map->info.origin));
                transforms.push_back(base_transform);
        }
        if(_slam_map)
        {
                grids.push_back(_slam_map);        
                geometry_msgs::msg::Transform slam_transform = geometry_msgs::msg::Transform();
                pose_to_transform(&slam_transform, &(_slam_map->info.origin));
                transforms.push_back(slam_transform);
        }

        if(!_slam_map && !_base_map)
        {
                return;
        }



        if(!_base_map)
        {
                std::cout << "no base map" << std::endl;
                RCLCPP_DEBUG(this->get_logger(), "no base map for combination");
        }
        if(!_slam_map)
        {
                std::cout << "no slam map" << std::endl;
                RCLCPP_DEBUG(this->get_logger(), "no SLAM map for combination");

        }


        // we don't need to lock here, because when have_initial_poses_ is true we
        // will not run concurrently on the pipeline
        _pipeline.feed(grids.begin(), grids.end());
        _pipeline.setTransforms(transforms.begin(), transforms.end());

        // nav_msgs::OccupancyGridPtr merged_map;
        nav_msgs::msg::OccupancyGrid::SharedPtr merged_map;
        {
                std::lock_guard<std::mutex> lock(_pipeline_mutex);
                merged_map = _pipeline.composeGrids();
        }
        if (!merged_map) {
                RCLCPP_ERROR(this->get_logger(), "Map combination failed");
                return;
        }

        // RCLCPP_DEBUG(logger_, "all maps merged, publishing");
        RCLCPP_DEBUG(this->get_logger(), "all maps merged, publishing");
        auto now = this->now();
        merged_map->info.map_load_time = now;
        merged_map->header.stamp = now;
        merged_map->header.frame_id = "map";

        // TODO fix cheat weil transform irgendwie nicht wie gewollt
        if(_base_map)
        {
                merged_map->info.origin.position.x = _base_map->info.origin.position.x;
                merged_map->info.origin.position.y = _base_map->info.origin.position.y;
                merged_map->info.origin.position.z = _base_map->info.origin.position.z;
        }

        _combined_map = merged_map;
        // rcpputils::assert_true(merged_map->info.resolution > 0.f);
        _merged_map_publisher->publish(*merged_map);
        _debug_base_map_publisher->publish(*_base_map);

}

}  // namespace robast_map_update


int main(int argc, char * argv[])
{
        rclcpp::init(argc, argv);
        rclcpp::spin(std::make_shared< robast_map_update::MapCombine>());
        rclcpp::shutdown();
        return 0;
}